\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in

% IJCAI 2026 style
\usepackage{ijcai26}

% Recommended IJCAI packages
\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{booktabs}
\usepackage{paralist}
\usepackage{todonotes}
\usepackage{comment}
\usepackage{color}
\usepackage[switch]{lineno}

\usepackage{xcolor}
\newcommand\btext[1]{{\color{blue}{#1}}}

\linenumbers
\urlstyle{same}

% PDF metadata required by IJCAI (title/authors intentionally omitted)
\pdfinfo{
/TemplateVersion (IJCAI.2026.0)
}

% Theorem-like environments
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{definition}{Definition}
\newtheorem{property}{Property}

\newenvironment{problem}[1]
  {\vspace{\baselineskip}\noindent\textbf{Problem} (#1).\itshape}
  {\par}

% Title and authors (placeholders to be updated)
\title{Surrogate-Based Smart Predict and Schedule}

\author{
  First Author$^1$\and
  Second Author$^2$\And
  Third Author$^3$\\
  \affiliations
  $^1$Affiliation One\\
  $^2$Affiliation Two\\
  $^3$Affiliation Three\\
  \emails
  first.author@example.com,
  second.author@example.com,
  third.author@example.com
}

\begin{document}

\maketitle

\begin{abstract}
Task scheduling under uncertainty is a fundamental challenge in artificial intelligence and operations research, with applications in manufacturing, logistics, cloud computing, and healthcare.
Smart predict-and-optimize (SPO) methods address this challenge by learning predictive models that directly minimize decision regret, but in practice they struggle with non-differentiable objectives and the discrete nature of optimal scheduling rules.
We propose a surrogate-based framework for smart predict-and-schedule that views polynomial-time scheduling algorithms---such as shortest-processing-time (SPT), earliest-due-date (EDD), FIFO, and Johnson's rule---as collections of critical decisions, and attaches to each decision a smooth sigmoid-based penalty weighted by its contribution to the scheduling objective.
We instantiate this framework on two classical problems: (i) single-machine scheduling with the sum of completion times (SCT) objective, where misordered job pairs are weighted by their SCT increase, and (ii) the two-machine flow shop with makespan minimization, where misclassified groups and misordered jobs are weighted by the corresponding Johnson swap costs.
Experiments on synthetic SCT benchmarks and a real-world outpatient scheduling dataset from a cancer hospital show that our surrogate-based approach consistently outperforms state-of-the-art SPO and learn-to-rank baselines across the vast majority of instances.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

Scheduling involves allocating limited resources to tasks over time to optimize objectives such as minimizing the sum of completion times (SCT), makespan, or weighted tardiness~\cite{baker2018principles,pinedo2022scheduling}.
It is a foundational problem in artificial intelligence and operations research, with applications in manufacturing, logistics, cloud computing, and healthcare.
Classical approaches typically assume that task parameters (e.g., processing times, release dates, due dates) are known and deterministic, enabling the use of efficient algorithms and priority rules such as SPT, EDD, FIFO, or Johnson's rule.
In reality, however, these parameters are uncertain and must be inferred from historical data.
This mismatch between deterministic models and stochastic environments motivates the development of data-driven decision-making methods that explicitly account for uncertainty in both prediction and optimization.

Smart predict-and-optimize (SPO) methods offer one such paradigm~\cite{elmachtoub2022smart}.
Rather than learning to predict task parameters in isolation, SPO couples prediction with downstream optimization by minimizing empirical \emph{decision regret}: the difference between the objective value of the decision induced by learned predictions and that of the optimal decision under the true parameters.
Despite their conceptual appeal, SPO methods face two major challenges in practice.
First, the regret objective is often non-differentiable and highly non-convex, making gradient-based learning difficult.
Second, even when differentiable surrogates such as SPO+ are available, they may be poorly aligned with the structure of specific scheduling rules and can exhibit unstable training behaviour, especially when small changes in predictions lead to large changes in the optimal schedule.

In this paper, we develop a surrogate-based framework that addresses these challenges for a broad class of polynomial-time scheduling algorithms.
The key idea is to exploit the structure of known optimal dispatching rules---such as SPT, EDD, FIFO, and Johnson's rule---and view them as finite sets of \emph{critical decisions} (e.g., pairwise orderings or group assignments) that fully determine the resulting schedule.
For each decision, we construct a smooth sigmoid-based penalty whose argument is a signed decision score and whose weight reflects the local impact of that decision on the scheduling objective (e.g., SCT increase or makespan increase).
This yields a differentiable ``ReLU-over-decision'' surrogate that penalizes costly misdecisions while remaining largely neutral on confidently correct ones, providing stable gradients that focus on ambiguous or high-impact decisions.

We then specialize this decision-level framework to scheduling under uncertainty.
Our primary case study is the single-machine SCT minimization problem, where we introduce a sigmoid-based surrogate that directly approximates regret by weighting misordered task pairs by their contribution to SCT.
We further show how the same principles extend to a two-machine flow shop with makespan minimization, where the deterministic optimal policy is given by Johnson's rule and the surrogate weights misgroupings and misorderings by the corresponding Johnson swap costs.
Across both problems, the resulting surrogates retain the interpretability of classical algorithms while enabling flexible learning with neural networks.

To validate our approach, we conduct extensive experiments on synthetic and real-world datasets.
On synthetic instances of the SCT problem, our surrogate consistently outperforms SPO+, logistic rank-loss, and mean-squared-error baselines, especially under high noise and large duration variability.
On a large-scale outpatient scheduling dataset from a cancer hospital, our method achieves the lowest relative SCT error across most months, demonstrating robustness in a noisy, feature-limited environment.

Our contributions can be summarized as follows:
\begin{enumerate}
    \item We propose a surrogate-based framework for smart predict-and-schedule that views polynomial-time scheduling rules (e.g., SPT, EDD, FIFO, Johnson's rule) as sets of critical decisions and derives differentiable sigmoid-based losses at the decision level.
    \item We instantiate this framework on two classical scheduling problems: (i) single-machine SCT minimization and (ii) two-machine flow shop makespan minimization, deriving problem-specific surrogates that weight each decision by its contribution to SCT or makespan.
    \item We provide theoretical guarantees for the SCT surrogate, including differentiability and convergence to regret as the sigmoid sharpness parameter tends to zero, and show how algorithmic structure (e.g., Johnson's rule and associated swap costs) guides surrogate design in the flow shop setting.
    \item We empirically evaluate our approach on synthetic SCT benchmarks and a real-world hospital scheduling dataset, demonstrating consistent improvements over state-of-the-art SPO, learn-to-rank, and predict-then-optimize baselines.
\end{enumerate}

\section{Surrogate-Based Predict-and-Optimize}
\label{sec:framework}

This section makes the paper's core premise explicit: many classical
\emph{polynomial-time scheduling rules} can be expressed as collections of
\emph{critical decisions} (comparisons, threshold tests, and group assignments)
that fully determine the resulting schedule.
We use this view to derive smooth, decision-level surrogate losses for
smart predict-and-schedule.
While the same idea can sometimes be transferred to other decision problems, we
do not claim universal applicability beyond settings where such a decomposition
is available.

\subsection{Problem Setting}

We consider a scheduling instance with $n$ jobs.
Each job $i$ has observed features $x_i \in \mathbb{R}^p$ and an unknown
parameter vector $\theta_i^\star$ (e.g., processing time, due date, or release
time).
Let $\theta^\star := (\theta_1^\star,\dots,\theta_n^\star)$ denote the
collection of true job parameters.
A schedule (or sequencing decision) is denoted by $\pi \in \Pi$, where $\Pi$
is the set of feasible schedules for the environment under study.
The resulting objective value under the true parameters is $C(\pi;\theta^\star)$,
where $C$ may represent, for example, sum of completion times or makespan.

The learning task is to learn
$\hat{\theta} = f_\omega(x)$ (with parameters $\omega$) by minimizing
the regret of using $\pi(\hat{\theta})$ instead of the
optimal solution, namely
\begin{equation}
\label{eq:regret-general}
R(\hat{\theta},\theta^\star)
:=
C(\pi(\hat{\theta});\theta^\star)
-
C(\pi(\theta^\star);\theta^\star),
\end{equation}
which is generally non-differentiable with respect to~$\omega$.
The framework 
below addresses this challenge by exploiting problem structure.

\noindent\textbf{Step 1: Identify Unknown Parameters (or Decision-Relevant Scores).}
For each job $i$, define the unknown parameter vector $\theta_i^\star$ governing
its contribution to the optimization problem (e.g., processing times, due dates,
or machine-dependent durations).
Let a dataset
$\mathcal{D}=\{(x_j,\theta_j^\star)\}_{j=1}^N$ be given, consisting of past
observations from which a predictor $f_\omega$ can be trained.
In some problems, it is convenient for $f_\omega$ to predict not the raw
parameters $\theta$ directly, but a set of \emph{decision-relevant scores} that
parameterize the critical decisions of the deterministic algorithm (Step~2).

\noindent\textbf{Step 2: Identify a Deterministic Polynomial-Time Counterpart.} Many optimization problems become tractable when $\theta^\star$ is known.
Suppose that, for known parameters $\theta$, the deterministic variant admits a
polynomial-time algorithm $\mathcal{A}$ that returns an optimal decision:
\[
\pi(\theta) = \mathcal{A}(\theta).
\]
Examples include single-machine scheduling problems where sorting rules are optimal, and
two-machine flow shops solved by Johnson’s rule, two problems which we tackle in this paper.
Such algorithms typically reveal a structural decomposition
$\mathcal{A}(\theta)$ that induces partitions, rankings, or threshold decisions.
This structure is key for constructing differentiable surrogates.

\noindent\textbf{Step 3: Derive a Smooth Surrogate from $\mathcal{A}$.} The deterministic algorithm $\mathcal{A}$ induces a discrete mapping from
parameters~$\theta$ to decisions~$\pi$.
To train a neural network via gradient
descent, we replace this mapping with a differentiable surrogate loss
$L_{\mathrm{surr}}$ that approximates the regret in
(\ref{eq:regret-general}).
The construction follows three principles:

\paragraph{(a) Structural decomposition.}
Let $\mathcal{A}$ determine a schedule through a finite set of \emph{critical
decisions} $\mathcal{D}$, such as:
(i) pairwise precedence comparisons (e.g., SPT/EDD/FIFO-style ordering
decisions), (ii) threshold tests, or (iii) group assignments (e.g., Johnson's
partition into $G_1$ and $G_2$).
Crucially, the elements of $\mathcal{D}$ need not be job pairs: in some rules
they are per-job classification decisions, and in others they are comparisons.

\paragraph{(b) Sigmoid relaxations.}
For each critical decision $d \in \mathcal{D}$, define a signed \emph{decision
score} $s_d(\omega;x)$ produced by the predictor, such that the sign of
$s_d$ encodes the model's preferred outcome for $d$ (e.g., ``$i$ before $j$''
or ``job $i \in G_1$'').
We then replace the hard, non-differentiable decision indicator by a smooth
sigmoid approximation.
To ensure the surrogate penalizes the \emph{wrong} outcome (rather than
encouraging a fixed sign), we orient each decision score using the true
parameters.
Specifically, define a \emph{signed correctness margin}
$m_d(\omega;x,\theta^\star)$ such that $m_d>0$ when the model agrees with the
ground-truth decision for $d$ (with margin) and $m_d<0$ otherwise.
In other words, $s_d$ is the model's \emph{raw} score for decision $d$, while
$m_d$ is the same score \emph{re-oriented} so that its sign always encodes
\emph{correctness}. Concretely, if under $\theta^\star$ the correct outcome for
$d$ corresponds to ``$s_d>0$,'' then $m_d=s_d$; if the correct outcome
corresponds to ``$s_d<0$,'' then $m_d=-s_d$.
We then use the smooth misclassification indicator
\[
\sigma\!\left( -\frac{m_d(\omega;x,\theta^\star)}{\lambda} \right),
\]
where $\lambda>0$ controls sharpness around the decision boundary $s_d=0$.

\paragraph{(c) Weighted aggregation.}
The surrogate loss is assembled as a weighted sum over critical decisions:
\begin{equation}
\label{eq:general-surrogate}
L_{\mathrm{surr}}(\omega)
:=
\sum_{d \in \mathcal{D}}
\phi_d(\theta^\star)\,
\sigma\!\left(
\frac{-m_d(\omega;x,\theta^\star)}{\lambda}
\right),
\end{equation}
where $\phi_d(\theta^\star)\ge 0$ measures the impact of deciding $d$ incorrectly
on the scheduling objective (e.g., SCT increase or makespan increase).
As $\lambda \to 0$, the surrogate approaches a hard penalty on incorrect
decisions, while for $\lambda>0$ it remains smooth and trainable with gradient
descent.

\noindent\textbf{Step 4: Train the Prediction Model.} The neural network $f_\omega$ is trained by minimizing the surrogate loss:
\[
\omega^\star
:= 
\arg\min_{\omega}
L_{\mathrm{surr}}(\omega).
\]
At inference time, the model produces either predicted parameters
$\hat{\theta}=f_{\omega^\star}(x)$ or decision-relevant scores that determine
the critical decisions; these are passed into the polynomial-time algorithm:
\[
\hat{\pi}
:=
\mathcal{A}(\hat{\theta}).
\]
This approach applies broadly to scheduling, routing, assignment, and other
combinatorial optimization problems in which the deterministic case is
tractable and structurally interpretable.
In this paper, we show two scheduling problems
under uncertainty that can be solved using our framework.

% \subsection{Implications for Scheduling Problems}
% \label{sec:framework-scheduling}

% Scheduling problems are a natural fit for the proposed framework because many
% deterministic scheduling objectives admit polynomial-time optimal rules with
% explicit structure.
% In such cases, the set $\mathcal{D}$ of critical decisions is not an
% abstraction: it corresponds to the comparisons and assignments performed by the
% rule itself.
% Importantly, $\mathcal{D}$ is \emph{problem- and rule-dependent} and does not
% have to be a set of job pairs.

% \paragraph{Examples of critical-decision sets.}
% \begin{itemize}
%     \item \textbf{SPT for $1\|\sum C_j$:}
%     $\mathcal{D}$ can be taken as pairwise precedence decisions
%     $d=(i,j)$ encoding ``$i$ should precede $j$'', induced by comparisons
%     of processing times.
%     \item \textbf{EDD for due-date objectives:}
%     $\mathcal{D}$ can similarly be precedence decisions based on due dates.
%     \item \textbf{FIFO in single-server queues:}
%     $\mathcal{D}$ encodes precedence decisions induced by arrival-time order.
%     \item \textbf{Johnson's rule for $F2\|C_{\max}$:}
%     $\mathcal{D}$ naturally decomposes into (i) per-job group-assignment
%     decisions (whether job $i$ belongs to $G_1$ or $G_2$) and
%     (ii) within-group ordering decisions.
%     The former are \emph{not} pairwise comparisons.
% \end{itemize}

% \paragraph{Why decision-level weights matter.}
% Weights $w_d(\theta^\star)$ are essential: they determine which mistakes the
% learning algorithm prioritizes.
% For SCT, swapping two jobs far apart in the sequence can have much larger
% impact than swapping two adjacent jobs; for Johnson's rule, misclassifying a
% job close to the boundary $p_{i1}=p_{i2}$ may be less harmful than
% misclassifying a job with a large margin, and some within-group misorderings
% increase makespan substantially more than others.

\subsection{Running Example: Outpatient Scheduling}
\label{sec:framework-running-example}

Consider a stylized outpatient clinic with a single exam doctor.
Patients $i=1,\dots,n$ arrive randomly with known appointment times and
uncertain exam durations.
Depending on the operational objective, a deterministic policy might implement
FIFO (serve in order of arrival), an EDD-like rule (serve those with earlier appointment times first), or 
an SPT-like rule (serve those with shorter predicted exams
first) as a proxy for minimizing waiting or completion-time objectives.

In this setting, a critical decision could be a precedence relation (``serve
patient $i$ before patient $j$''), but it could also be a per-patient
classification decision (``patient $i$ belongs to the short-visit group''),
depending on the scheduling rule used.
The surrogate in Eq.~\eqref{eq:general-surrogate} penalizes incorrect or ambiguous
decisions through $\sigma(-m_d/\lambda)$ and uses $\phi_d(\theta^\star)$ to reflect
their downstream impact (e.g., increase in total waiting time or SCT).
This connects directly to the hospital case study in
Section~\ref{sec:case_study}, where our learning objective is designed to
improve the resulting patient sequencing rather than pointwise duration
accuracy.

In the remainder of the paper, we instantiate the framework on two canonical
problems: single-machine SCT minimization (Problem~1) and two-machine flow shop
makespan minimization (Problem~2).
For each, we derive a problem-specific surrogate by specifying (i) the set of
critical decisions $\mathcal{D}$ and (ii) the weights $\phi_d$.

\section{Problem 1: Single-Machine Scheduling}
\label{sec:problem1}

We now instantiate the four-step framework of Section~\ref{sec:framework} for the
single-machine sum of completion times (SCT) objective.
The deterministic counterpart is solved by the shortest-processing-time (SPT)
rule; we derive a smooth, decision-level surrogate that targets the pairwise
precedence decisions induced by SPT and weights each potential misordering by
its SCT impact.

\noindent\textbf{Step 1: Identify Unknown Parameters.}
In this problem, the unknown parameter for each task $i$ is its processing time
$y_i>0$. In the notation of Section~\ref{sec:framework}, we write
$\theta_i^\star := y_i$ and $\theta^\star := (\theta_1^\star,\dots,\theta_n^\star)$.
We observe features $x_i\in\mathbb{R}^p$ and learn a predictor
$\hat{\theta}_i = f_\omega(x_i)$ from a dataset
$\mathcal{D} = \{(x_j, \theta_j^\star)\}_{j=1}^N$ (equivalently, $\hat{y}_i=\hat{\theta}_i$).

\noindent\textbf{Step 2: Deterministic Polynomial-Time Counterpart.}

\paragraph{Deterministic problem.}
We consider the following single-resource scheduling setting: a resource is assigned to process $n$ tasks (e.g., jobs scheduled for a given day).
All $n$ tasks are assumed to be available at the beginning of the scheduling period, but their processing times are unknown.
The resource is non-idling, working continuously until all tasks are completed.
The objective is to find a task sequencing that minimizes the sum of completion times (SCT).
When the true durations $y_1, \ldots, y_n$ are known, the optimal sequence follows the shortest processing time first (SPT) heuristic, arranging tasks in ascending order of their durations~\cite{pinedo2022scheduling}.
Equivalently, letting $\theta=(\theta_1,\dots,\theta_n)$ denote processing
times, the deterministic algorithm is
\(
\pi(\theta)=\mathcal{A}_{\mathrm{SPT}}(\theta)
\),
where $\mathcal{A}_{\mathrm{SPT}}$ sorts tasks by increasing $\theta_i$.

In realistic settings, however, the actual task durations are unknown.
Instead, historical data with features correlated with task durations are available.
This historical data can be used to predict task durations and subsequently schedule the tasks using the SPT rule.
However, prediction errors can lead to suboptimal schedules.

\paragraph{Modeling uncertainty in task durations.}
Adopting a supervised learning framework, we assume the following model~\cite{hastie2009elements}:
\begin{equation} \label{eq:master_ppm}
y_i = f(x_i) + \epsilon_i,
\end{equation}
where $f$ is an unknown deterministic function, and $\epsilon_i$ is a random noise term with mean $0$ and variance $\sigma^2$ (identically distributed across tasks).

\paragraph{Baseline learning approach.}
A straightforward approach is the predict-then-optimize paradigm~\cite{Mandi2020},
in which $f_\omega$ is learned by minimizing empirical mean squared error (MSE):
\begin{equation}
\omega^\star_{\mathrm{MSE}}
=
\arg\min_{\omega} \sum_{j=1}^{N} \bigl(f_\omega(x_j) - y_j\bigr)^2,
\end{equation}
The resulting model predicts durations $\hat{y}_i=f_{\omega^\star_{\mathrm{MSE}}}(x_i)$,
and the optimization phase schedules tasks by sorting predicted durations (SPT).
In Section~\ref{sec:framework} notation, this corresponds to computing
$\hat{\theta}_i=f_{\omega^\star_{\mathrm{MSE}}}(x_i)$ and then
$\hat{\pi}=\mathcal{A}_{\mathrm{SPT}}(\hat{\theta})$.

In other words, prediction errors are unavoidable, but not all impact the task order in scheduling.
MSE treats all errors the same, even though only those that change task order impact the SCT objective.
Thus, minimizing MSE may not effectively reduce SCT, as it overlooks the distinction between harmless and harmful errors.

To better understand this, consider a sequencing of tasks where the task placed in position \(k\) has duration \(y_k\).
The total SCT can be expressed as:
\begin{equation}
\mathrm{SCT} = \sum_{k=1}^n (n+1-k) \, y_k.
\end{equation}

Swapping two tasks at positions \(i < j\) alters their contribution by:
\begin{align}
R_{i,j} &= \big[(n{+}1{-}i)\, y_j + (n{+}1{-}j)\, y_i\big] \nonumber \\
       &\quad - \big[(n{+}1{-}i)\, y_i + (n{+}1{-}j)\, y_j\big] \nonumber \\
       &= (j - i)(y_j - y_i).
\end{align}

A pair \((i,j)\) is said to be \emph{misordered} if \(y_i < y_j\) but the schedule places \(y_i\) after \(y_j\), leading to an increase in SCT of \((j-i)(y_j - y_i)\).
Clearly this conditional error, which represents the actual cost of mispredicting task durations, has a different structure from the MSE, which represents the incurred cost of mispredicting task durations.
To solve this problem, we aim to find a loss function for the prediction phase, different from MSE, that minimizes the actual cost of mispredicting task durations.

%\subsection{Regret Formulation for SCT}

Accordingly, we define the smart predict-and-schedule problem in terms of regret.

\begin{problem}{Regret minimization in SCT} \label{prob:problem1}
Find $f_\omega$ that minimizes the expected regret:
\begin{equation} \label{eq:smartsched}
L_{\text{regret}} = \sum_{\substack{\theta_i^\star < \theta_j^\star}} R_{i,j} \cdot \max(0, \text{sign}(f_\omega(x_i) - f_\omega(x_j))).
\end{equation}
\end{problem}

For example, consider two tasks \(i\) and \(j\) with true durations \(y_i < y_j\).
If \(f_\omega(x_i) > f_\omega(x_j)\), the tasks are misordered, increasing the SCT.
The regret-based loss directly targets such misorderings by reducing their probability.
This means that even large prediction errors may be tolerated if they are symmetric, regardless of their impact on task ordering.
In contrast, regret-based models focus explicitly on getting the order right, yielding better scheduling decisions even when prediction accuracy is imperfect.

Yet, directly optimizing regret is challenging due to non-differentiability and
the combinatorial nature of ordering tasks~\cite{elmachtoub2022smart}.
We therefore derive a differentiable surrogate loss that targets the critical
pairwise precedence decisions of SPT and weights each decision by its SCT
impact.

\noindent\textbf{Step 3: Derive a Smooth Surrogate from SPT.}
\label{sec:methodology}

The critical decisions for SPT are pairwise precedence comparisons.
For a pair $(i,j)$, define the decision score
\(
s_{i,j}(\omega;x)= \hat{\theta}_i-\hat{\theta}_j = f_\omega(x_i)-f_\omega(x_j)
\),
whose sign encodes the model's preference.
When $\theta_i^\star<\theta_j^\star$ (i.e., $y_i<y_j$), the correct order is
$i$ before $j$, and a misordering occurs
when $s_{i,j}(\omega;x)>0$.
We approximate this hard indicator with a sigmoid
\(\sigma(s_{i,j}(\omega;x)/\lambda)\), weighted by the SCT impact of the swap.

\paragraph{Sigmoid loss for SPO.}

The proposed sigmoid-based loss penalizes misordered task pairs, encouraging the model to predict task durations aligned with their true ordering.
The empirical sigmoid loss is defined as:
\begin{equation}
L_{\text{sigmoid}}
\;=\;
\sum_{\substack{\theta_i^\star < \theta_j^\star}}
  R_{i,j}\,
  \sigma\!\Bigl( \tfrac{f_\omega(x_i) - f_\omega(x_j)}{\lambda} \Bigr),
\end{equation}
where \(\sigma(x) = \tfrac{1}{1+e^{-x}}\) is the sigmoid function, and \(\lambda>0\) controls the steepness around misordered predictions.
A larger \(\lambda\) smooths transitions, while a smaller \(\lambda\) sharpens sensitivity to misorderings.

By minimizing the empirical sigmoid loss, the learned model \(f_\omega\) is encouraged to satisfy \(f_\omega(x_j) > f_\omega(x_i)\) whenever \(\theta_j^\star > \theta_i^\star\).
Formally:
\[
\omega^\star
\;=\;
\arg\min_{\omega}
  L_{\text{sigmoid}}(\omega),
\]
Thus, training adjusts \(f_\omega\) to minimize the number and severity of misordered pairs, aligning predictions with true task durations.
When \(f_\omega\) preserves correct orderings, the sigmoid term remains near zero, driving \(L_{\text{sigmoid}}\) downward.

\noindent\textbf{Step 4: Train and Infer with SPT.}

At inference time, given a new instance with features $\{x_i\}_{i=1}^n$, we
compute $\hat{\theta}_i=f_{\omega^\star}(x_i)$ and return
$\hat{\pi}=\mathcal{A}_{\mathrm{SPT}}(\hat{\theta})$, i.e., the SPT schedule
obtained by sorting tasks by $\hat{\theta}_i$ in ascending order.

% \subsubsection{Properties of the sigmoid-based surrogate}

% To show the usefulness of the sigmoid-based surrogate loss function for predict and schedule, we need to show that it is differentiable and approximates the regret in the SCT problem.

% The non-differentiability of the regret loss in Equation~\ref{eq:smartsched} is caused by the use of \(\max(0, \text{sign}(x))\), effectively a \(\text{ReLU}(\text{sign}(x))\) operation that is non-differentiable at \(x=0\).
% To solve the non-differentiability problem, we replace this with the sigmoid function \(\sigma(x)\) as a smooth approximation, enabling gradient-based optimization.
% Several properties of the sigmoid-based surrogate support its effectiveness:

% \begin{property}[Differentiability and smooth gradients]
% \label{prop:differentiability}
% The surrogate loss \(L_{\text{sigmoid}}\) is infinitely differentiable.
% The derivative of the sigmoid function is:
% \[
% \sigma'(u) = \sigma(u)(1-\sigma(u)).
% \]
% \end{property}
% \noindent Differentiability ensures stable gradient-based optimization throughout training, which allows us to train a neural network to solve
% the scheduling problem via an SPO-like method.

% \begin{property}[Tunable sensitivity via \(\lambda\)]
% The steepness of the decision boundary is controlled by \(\lambda>0\).
% \end{property}
% \begin{proof}
% The derivative \(\sigma'(u)\) is maximized near \(u=0\).
% Smaller \(\lambda\) values sharpen the sigmoid, increasing sensitivity to small misorderings.
% \end{proof}
% \noindent The hyperparameter \(\lambda\) thus offers a mechanism to fine-tune model responsiveness to near-boundary predictions.
% Higher $\lambda$
% yields low penalty for misorderings, while low values of $\lambda$
% push the objective to converge to Equation~\ref{eq:smartsched}.

% \begin{property}[Order sensitivity and penalization]
% \label{prop:order}
% The sigmoid loss penalizes misordered task pairs.
% \end{property}
% \begin{proof}
% For tasks \(i\) and \(j\) where \(y_j > y_i\), the loss contribution is:
% \[
% (j-i)(y_j-y_i)\,\sigma\!\Bigl(\tfrac{\hat{f}(x_i) - \hat{f}(x_j)}{\lambda}\Bigr).
% \]
% Correctly ordered pairs (\(\hat{f}(x_j) > \hat{f}(x_i)\)) yield negative inputs to \(\sigma\), resulting in near-zero penalties.
% Incorrectly ordered pairs (\(\hat{f}(x_i) > \hat{f}(x_j)\)) yield positive inputs, maximizing the penalty.
% \end{proof}
% \noindent As \(\lambda\to\infty\), all penalties converge to a uniform value, diminishing order sensitivity.

% \begin{property}[Sensitivity to small misorderings]
% \label{prop:sensitivity}
% The sigmoid loss penalizes near-boundary cases where \(\hat{f}(x_i) \approx \hat{f}(x_j)\).
% \end{property}
% \begin{proof}
% When \(\hat{f}(x_i) \approx \hat{f}(x_j)\), the input to the sigmoid approaches zero, yielding:
% \[
% \sigma(0) = 0.5.
% \]
% Thus, pairs with uncertain ordering are still penalized, encouraging the model to separate predictions more clearly.
% \end{proof}

% Finally, we present a convergence guarantee:

% \begin{theorem}[Convergence to regret loss]
% \label{thm:lambda_impact}
% The surrogate loss \(L_{\text{sigmoid}}\) converges to the regret loss \(L_{\text{regret}}\) as \(\lambda \to 0\).
% \end{theorem}
% \begin{proof}
% As \(\lambda \to 0\), the scaled differences \((\hat{f}(x_i)-\hat{f}(x_j))/\lambda\) tend toward \(\pm\infty\), and the sigmoid function \(\sigma(u)\) converges to a step function:
% \[
% \sigma(u) \to 
% \begin{cases}
% 1, & u > 0, \\
% 0, & u \leq 0,
% \end{cases}
% \]
% thus recovering the original regret loss.
% \end{proof}
% \noindent These properties position the sigmoid-based surrogate as a natural fit for learning-based scheduling under uncertainty.

% \subsubsection{Limitations of the sigmoid-based loss}

% While effective for single-machine SCT minimization, several limitations remain.
% First, the method has not been extended to multi-machine or distributed scheduling scenarios.
% Handling task dependencies, release times, or resource constraints would require significant modifications.
% Second, the hyperparameter \(\lambda\) critically influences model performance.
% Improper selection may cause either unstable training (if \(\lambda\) is too small) or diminished order sensitivity (if \(\lambda\) is too large), necessitating careful hyperparameter tuning.
% Third, pairwise loss computation scales quadratically with the number of tasks, which may become computationally expensive for large-scale instances.
% Although sampling techniques can mitigate this, further work is needed to improve scalability. 
% Finally, the underlying deterministic scheduling problem must be solvable in polynomial time; otherwise, training becomes computationally infeasible, as exact solutions used in the learning process are not efficiently obtainable.

% Addressing these limitations is an important direction for future work, with the goal of broadening the applicability of surrogate-based scheduling methods to more complex and large-scale environments.

\section{Problem 2: Flow Shop Scheduling}
\label{sec:flowshop}

The surrogate framework developed in Section~\ref{sec:framework} naturally extends
to other scheduling problems whose optimal deterministic policies admit simple
structural characterizations.
In this section, we demonstrate this by considering
the classical two-machine flow shop scheduling problem with makespan minimization,
denoted $F2\|C_{\max}$, for which the optimal policy is given by Johnson’s rule.
We show how to construct a smooth surrogate loss that mimics the structure of
the optimal rule while remaining differentiable and suitable for gradient-based
learning.

\noindent\textbf{Step 1: Identify Unknown Parameters.}
In the $F2\|C_{\max}$ setting, the unknown parameters for each job $i$ are its
two processing times on machines $1$ and $2$. In the notation of
Section~\ref{sec:framework}, let
$\theta_i^\star := (p_{i1},p_{i2})$ and
$\theta^\star := (\theta_1^\star,\dots,\theta_n^\star)$.

\noindent\textbf{Step 2: Deterministic Polynomial-Time Counterpart.}

In the $F2\|C_{\max}$ setting, each job $i$ has two true processing times 
$(p_{i1}, p_{i2})$, one for each machine.
Johnson’s rule partitions all jobs into
two sets:
\[
G_1 = \{ i : p_{i1} < p_{i2} \}, 
\qquad
G_2 = \{ i : p_{i1} \ge p_{i2} \},
\]
orders $G_1$ in ascending $p_{i1}$, orders $G_2$ in descending $p_{i2}$, and 
concatenates the two sequences.
Consequently, the optimal sequence is determined
by (i) the correct group assignment of each job and (ii) the correct ordering 
within each group.
Equivalently, for known processing times $\theta$, the deterministic optimum is
\(
\pi(\theta)=\mathcal{A}_{\mathrm{J}}(\theta)
\),
where $\mathcal{A}_{\mathrm{J}}$ is Johnson's rule.

When processing times are unknown and must be predicted from features $x_i$, we
follow the Section~\ref{sec:framework} view and predict \emph{decision-relevant
scores} that parameterize the critical decisions of $\mathcal{A}_{\mathrm{J}}$.
Concretely, each job $i$ is mapped to two scalar scores
\[
(\hat{d}_i, \hat{s}_i) = f_\omega(x_i)=:\hat{\theta}_i,
\]
where $\hat{d}_i \in \mathbb{R}$ is a \emph{group score} indicating whether the
job should belong to $G_1$ or $G_2$, and $\hat{s}_i \in \mathbb{R}$ is a
\emph{sortable score} used to determine the job’s relative position \emph{within}
its assigned group.
The predicted sequence then follows the structure of Johnson’s rule:
\begin{enumerate}
    \item Assign each job to $\hat{G}_1$ if $\hat{d}_i < 0$ and to $\hat{G}_2$ otherwise.
    \item Sort $\hat{G}_1$ by increasing $\hat{s}_i$.
    \item Sort $\hat{G}_2$ by decreasing $\hat{s}_i$.
\end{enumerate}

This parameterization separates the discrete grouping decision from the within-group ranking
decision, reflecting the decomposition inherent in Johnson’s optimal policy.
At inference time, we apply the same deterministic structure,
$\hat{\pi}=\mathcal{A}_{\mathrm{J}}(\hat{\theta})$, using $\hat{\theta}_i=(\hat{d}_i,\hat{s}_i)$.

\noindent\textbf{Step 3: Derive a Smooth Surrogate from Johnson's Rule.}

To train the model, we define a smooth surrogate loss consisting of two components:
(1) a penalty for incorrect \emph{group assignment}, and
(2) a penalty for incorrect \emph{within-group ordering}.
Both components rely on sigmoidal approximations of indicator functions, as in
Section~\ref{sec:methodology}.

\paragraph{Group assignment surrogate.}
For each job $i$, the true group indicator satisfies
\[
d_i = p_{i1} - p_{i2},
\qquad
i \in G_1 \iff d_i < 0.
\]
Incorrect assignment occurs when the predicted sign of $\hat{d}_i$ differs from the
true sign of $d_i$.
We define the group surrogate loss as
\begin{equation}
L_{\mathrm{group}}
:= 
\sum_{i} 
w_i \,
\sigma\!\left( -\frac{\hat{d}_i\, d_i}{\lambda} \right),
\label{eq:group-loss}
\end{equation}
where $\sigma$ is the sigmoid function, $\lambda>0$ controls smoothness, and
$w_i = |d_i|$ weights mistakes according to the severity of misclassification
(the farther a job is from the decision boundary $p_{i1} = p_{i2}$, the more 
important it is to assign it correctly).
The term in~\eqref{eq:group-loss} is
small when $\hat{d}_i$ has the correct sign with sufficient margin, and close to
1 otherwise.

\paragraph{Within-group surrogate.}
Conditioned on correct group membership, the regret of the flow shop policy arises
from misordering jobs within $G_1$ or $G_2$.
For two jobs $i,j$:
\begin{itemize}
    \item If $i,j \in G_1$ and $p_{i1} < p_{j1}$, then $i$ should precede $j$.
    \item If $i,j \in G_2$ and $p_{i2} > p_{j2}$, then $i$ should precede $j$.
\end{itemize}
To align the surrogate with makespan regret, we weight each potential swap by
its impact on completion time.
For two jobs $i$ and $j$ on machines $1$ and $2$, let
\begin{equation}
T_{i,j} = p_{i1} + \max(p_{i2},p_{j1}) + p_{j2},
\end{equation}
\begin{equation}
T_{j,i} = p_{j1} + \max(p_{j2},p_{i1}) + p_{i2},
\end{equation}
and define the incremental cost of placing $j$ before $i$ instead of the
correct order as
\begin{equation}
\Delta_{i,j} = T_{j,i} - T_{i,j}.
\end{equation}
We then set the within-group surrogate to
\begin{equation}
\label{eq:order-loss}
\resizebox{0.95\linewidth}{!}{$
\displaystyle
L_{\mathrm{order}}
:=
\sum_{\substack{i,j \in G_1 \\ p_{i1} < p_{j1}}}
\Delta_{i,j}\, \sigma\!\Big( \tfrac{\hat{s}_i - \hat{s}_j}{\lambda} \Big)
 +
\sum_{\substack{i,j \in G_2 \\ p_{i2} > p_{j2}}}
\Delta_{i,j}\, \sigma\!\Big( \tfrac{\hat{s}_j - \hat{s}_i}{\lambda} \Big)
$}\,.
\end{equation}
As in the SCT surrogate, the sigmoid penalizes misordered pairs (i.e., cases where
$\hat{s}_i > \hat{s}_j$ despite $i$ being correctly ordered before $j$), with 
penalties scaled by the corresponding increase in makespan $\Delta_{i,j}$.

\paragraph{Combined surrogate and properties.}
The full surrogate loss for Johnson’s rule is the simple additive combination
of group and ordering components:
\begin{equation}
\label{eq:johnson-loss}
L_{\mathrm{Johnson}}
:=
L_{\mathrm{group}}
+
L_{\mathrm{order}}.
\end{equation}
By construction, $L_{\mathrm{Johnson}}$ is infinitely differentiable in the
network parameters, and jobs whose misclassification or misordering has a
larger impact on the makespan (larger $|d_i|$ or $\Delta_{i,j}$) receive
larger weights.
As $\lambda \to 0$, the sigmoids in~\eqref{eq:group-loss} and
~\eqref{eq:order-loss} approach hard indicators of incorrect group assignment
and within-group ordering, so that $L_{\mathrm{Johnson}}$ converges to a
piecewise-constant approximation of the true makespan regret induced by
Johnson's rule.

\noindent\textbf{Step 4: Train and Infer with Johnson's Rule.}

We train $f_\omega$ by minimizing the surrogate $L_{\mathrm{Johnson}}$.
At inference time, given a new instance with features $\{x_i\}_{i=1}^n$, we
compute $(\hat{d}_i,\hat{s}_i)=f_{\omega^\star}(x_i)$ and construct the schedule
using the three-step Johnson-style procedure above (partition into
$\hat{G}_1,\hat{G}_2$, sort within each group, then concatenate).


\section{Evaluation}
\label{sec:evaluation}

This section details the empirical evaluation of the proposed approach on the single-machine SCT problem (Problem~1).
We first describe the experimental setup, including dataset generation, benchmark methods, implementation details, and evaluation metrics.
Next, we outline the experimental procedure for solving the scheduling problem and compare our method against existing baselines.
Finally, we present the main experimental results and discuss the applicability and scalability of our approach.

\subsection{Experimental Setup}

Experiments were conducted on synthetically generated datasets to evaluate the performance of the sigmoid-based surrogate loss under a range of scheduling scenarios.
The experiments systematically varied data generation models, noise levels, task duration ranges, and benchmark comparisons.

\paragraph{Datasets.}
We constructed two synthetic datasets using linear and nonlinear functions to simulate varying complexity levels.
This setup offers full control over noise and duration variability, allowing us to isolate the effect of surrogate loss choice.
In the absence of established benchmarks, these two datasets support systematic evaluation.
\begin{itemize}
    %\item \emph{Linear model:} \( f(x) = \mathbf{xw} \), where \(\mathbf{w}\) is a randomly generated weight vector, and \(\mathbf{x}\) consists of features uniformly sampled from \([0, 1]\).
    
    \item \emph{Nonlinear model:} A nonlinear combination is computed as:
    \[
    g(x) = 1.5x_1^2 + 2.0\sin(2\pi x_2) + x_3x_4 + 0.75x_5^3,
    \]
    where \(x_1, \dots, x_5\) are uniformly sampled features.
    This specific structure introduces smooth nonlinearities, feature interactions, and periodic components, capturing diverse patterns typical of real-world systems.
    The function was chosen to ensure that the learning task remains nontrivial, requiring the model to capture both local and global feature dependencies, while still being interpretable and reproducible.
    The final task durations were computed as:
    \[
    f(x) = 50 + g(x),
    \]
    ensuring strictly positive durations. %, typically in the range \([50, 400]\) under standard settings.
\end{itemize}

Gaussian noise with standard deviation $\sigma$ was added to simulate uncertainty.

\paragraph{Benchmark methods.}
We compared our method against two strong baselines.
The first is \emph{SPO+}, a convex surrogate loss designed for predict-and-optimize tasks \cite{elmachtoub2022smart}, which focuses predictions on minimizing decision regret.
The second is the \emph{logistic rank loss}, a learn-to-rank (LTR) surrogate loss %\cite{fu2024efficient} 
that penalizes incorrect pairwise orderings using logistic regression.

\paragraph{Implementation details.}
The experiments were implemented in Python.
Neural networks were built using PyTorch, with preprocessing handled by NumPy and scikit-learn.
Visualizations used Matplotlib.
Random seeds were fixed for reproducibility, and each experiment was repeated across multiple runs.
Confidence intervals were computed via bootstrapping. 

\paragraph{Evaluation metric.}
The primary evaluation metric was the SCT achieved by predicted task orderings.
Lower SCT values indicate better scheduling performance.
Percentage improvements relative to the proposed surrogate-based method were also reported.
SCT errors were visualized on a logarithmic scale to highlight relative differences across noise levels and duration ranges.

\subsection{Experimental Procedure}

Datasets were generated using the described models, with varying noise levels and task duration ranges.
Two experimental settings were considered:
\begin{itemize}
    %\item \emph{Noise levels:} The \texttt{scale\_factor} was varied to assess performance under different task duration variability.
    \item \emph{Noise levels:} Noise levels (\(\sigma\)) were varied to evaluate model robustness to prediction uncertainty.
\end{itemize}
Each dataset was normalized and split into 70\% training, 10\% validation and 20\% test subsets.

For each setting, models were trained with \emph{SPO+}, \emph{Rank Loss}, and the \emph{Sigmoid Surrogate} objectives using two-hidden-layer neural networks.
\todo[inline]{Explain better pairwise concept}
Training used the Adam optimizer with early stopping, and pairwise methods sampled task pairs per iteration.
Models were evaluated on unseen test data by comparing SCT values against the true optimal order, with results averaged over ten runs.

\subsection{Results}

Single machine, and then for 2-flowshop.

\begin{comment}
    Figure~\ref{fig:all-methods-comparison} presents a comparison of SPO+, Rank Loss, and the proposed sigmoid surrogate on nonlinear datasets with uneven task durations.
The x-axis shows the noise standard deviation, and the y-axis plots the logarithmic SCT error relative to the optimal solution.
The sigmoid surrogate demonstrates robustness across noise levels, consistently achieving lower SCT compared to SPO+ and Rank Loss.

Figure~\ref{fig:improvement-percentages} shows the percentage improvement of SPO+ and Rank Loss relative to the sigmoid surrogate.
Although SPO+ and Rank Loss perform competitively under low-noise conditions, their relative performance deteriorates as noise increases, underscoring the robustness of the proposed approach.

Figure~\ref{fig:range-impact} examines performance as task duration ranges vary under a fixed noise level.
The sigmoid surrogate maintains lower SCT errors across wide variability, highlighting its effectiveness in challenging scheduling scenarios.
Our results demonstrate that the proposed sigmoid-based surrogate consistently outperforms SPO+ and Rank Loss in minimizing SCT, particularly under high-noise and high-variability conditions. 

Turning to efficiency analysis, Table~\ref{tab:runtimes} reports the average runtime over 10 iterations for each method under consistent settings.
The sigmoid method averaged 58.3 seconds, SPO+ averaged 57.3 seconds, and Rank Loss averaged 58.2 seconds, demonstrating comparable computational costs across methods.
While runtime is comparable across methods, the improved SCT minimization offered by the sigmoid surrogate positions it as a promising choice for real-world scheduling applications involving uncertainty and variability.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.45\textwidth]{compare-methods-fixed-range.png}
    \caption{Comparison of SPO+, Rank Loss, and the proposed surrogate method on nonlinear datasets.
    SCT error (logarithmic scale) relative to the optimal schedule is shown.}
    \label{fig:all-methods-comparison}
\end{figure}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.45\textwidth]{improvement--percentage.png}
    \caption{Percentage improvement of SPO+ and Rank Loss relative to the sigmoid surrogate.
    Positive values indicate worse performance compared to the sigmoid surrogate loss.}
    \label{fig:improvement-percentages}
\end{figure}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.45\textwidth]{fixed--noise (2).png}
    \caption{Impact of task duration range variability on SCT error for the three methods.}
    \label{fig:range-impact}
\end{figure}

\begin{table}[t]
\centering
\caption{Average runtime over 10 iterations per method.}
\label{tab:runtimes}
\begin{tabular}{lcc}
\toprule
Method & Runtime (seconds) \\
\midrule
Sigmoid surrogate & 58.3 \\
SPO+ surrogate & 57.3 \\
Rank Loss & 58.2 \\
\bottomrule
\end{tabular}
\end{table}

\end{comment}

%\section{Experiments: Two-Machine Flow Shop}
%\label{sec:flowshop-experiments}

Designing and evaluating surrogates for the two-machine flow shop (Problem~2) follows the same principles as in the SCT case but requires careful handling of both group assignments and within-group orderings.
In this version of the paper, we focus on presenting the surrogate construction and leave a full empirical study of the flow shop surrogate to future work.
Below we outline the intended experimental design to clarify how our framework extends empirically to this setting.

\paragraph{Planned datasets and baselines.}
We plan to generate synthetic flow shop instances with known processing times $(p_{i1},p_{i2})$ and derive features from them, mirroring the setup in Section~\ref{sec:evaluation}.
Baselines will include (i) predict-then-optimize with MSE on processing times, (ii) SPO+ adapted to the flow shop objective, and (iii) generic ranking surrogates that ignore Johnson's structure.

\paragraph{Planned evaluation.}
The primary metric will be relative makespan, comparing the schedule induced by learned predictions against the optimal Johnson schedule under true processing times.
We expect the Johnson-aligned surrogate in Section~\ref{sec:flowshop} to outperform baselines, particularly under high noise, by directly encoding the structure of the deterministic optimal policy.

\section{Case Study: Patient Scheduling}
\label{sec:case_study}

We evaluate the proposed sigmoid-based surrogate loss on a real-world dataset
from \textit{DayHospital}, a U.S.\ cancer clinic. We describe the setting,
experimental protocol, and results.

\subsection{Case Description: Scheduling in DayHospital}

DayHospital is an outpatient clinic where patients arrive in the morning and
complete their visits later in the day. Visits may include a blood draw, an
examination, and chemotherapy infusion. We focus on the \emph{examination}
stage: doctors act as single-server machines and patients are jobs, with known
appointment (arrival) times but \emph{uncertain} exam durations.
The goal is to sequence exams to reduce congestion, as duration uncertainty can
create large downstream delays.

\subsection{Experimental Setup}

\paragraph{Dataset.} 
We used two months of operational data from \textit{DayHospital} (January and
November 2021). Data sources include:
\begin{itemize}
    \item \emph{Real-Time Location System (RTLS)} traces (3-second resolution).
    \item \emph{Appointment data} with scheduled times.
\end{itemize}
The dataset contains approximately 201,000 patient pathways. For each observed
patient at a station, we extract arrival, service-start, and service-completion
timestamps. After preprocessing, we focus on \textit{Exam} appointments. The
goal is to predict true durations \(y_i\) from features \(x_i\) in a way that
improves SCT under sequencing.

Feature vectors \(x_i\) include \texttt{floor\_id}, \texttt{scheduled\_time},
\texttt{department}, \texttt{scheduled\_duration\_min}, \texttt{diagnosis},
\texttt{appointment\_type}, and \texttt{link\_flag} (whether the exam is
followed by infusion).

To reflect deployment, we split by calendar time: for each month, train on the
first three weeks and evaluate on the fourth week (rolling-horizon generalization).

\paragraph{Benchmark methods.}
We evaluated our proposed approach against several benchmark loss functions commonly used in predictive scheduling tasks:
\begin{itemize}
    \item \emph{Rank Loss}: pairwise ranking via negative log-likelihood of correct comparisons.
    
    \item \emph{Mean Squared Error (MSE)}: standard regression loss; a predict-then-optimize baseline~\cite{shahabikargar2014predicting}.
    
    \item \emph{SPO+}: A convex surrogate loss for predict-and-optimize problems \cite{elmachtoub2022smart}, which approximates the scheduling regret through a differentiable upper bound on the decision loss.
\end{itemize}

\paragraph{Evaluation metric.}
As in the synthetic experiments, the evaluation objective for the real-world data is to minimize the SCT induced by the predicted task orderings.
For each model, predicted durations were used to sequence appointments, and the resulting SCT was computed based on the true durations.
To facilitate comparison across months and models, we report the \emph{relative SCT error}, defined as the difference between the predicted and optimal SCT values, normalized by the optimal SCT.
This reflects scheduling regret and matches the synthetic evaluation.

\subsection{Experimental Procedure}

Models are feedforward neural networks with two hidden layers (ReLU) and a
Softplus output. All methods use Adam (\(5\times10^{-3}\) learning rate,
\(10^{-4}\) weight decay) with early stopping. We train up to 2000 iterations
and evaluate relative SCT error every 50 steps by sequencing with predicted
durations \(\hat{y}_i\) and comparing SCT against the optimal order under true
durations \(y_i\). SPO+ uses a mini-batch surrogate with a differentiable LP.
All methods share the same splits and comparable model capacity.

\subsection{Results}

To assess the robustness of each method across time, we evaluated model performance on monthly datasets spanning January to December 2021.
Table~\ref{tab:monthly-sct} reports the final relative SCT error per method (ours is denoted SIG for sigmoid-based) in each month.
The bottom row presents the average SCT error across the year.
Our sigmoid-based method consistently outperforms baselines (except August 2021), achieving the lowest average error and demonstrating stable performance across different months.

\begin{table}[t]
\centering
\caption{Final relative SCT errors across months of 2021 for each method.
Average values: SPO+= 0.476, LTR= 0.338, MSE= 0.353, and SIG= \textbf{0.316}.}
\label{tab:monthly-sct}
\begin{tabular}{lcccccc}
\toprule
Method & Jan & Feb & Mar & Apr & May & Jun \\
\midrule
SPO+     & 0.48 & 0.56 & 0.53 & 0.53 & 0.52 & 0.42 \\
LTR      & 0.33 & 0.36 & 0.33 & 0.35 & 0.33 & 0.33 \\
MSE      & 0.35 & 0.38 & 0.36 & 0.35 & 0.34 & 0.34 \\
Sigmoid  & \textbf{0.31} & \textbf{0.34} & \textbf{0.33} & \textbf{0.33} & \textbf{0.30} & \textbf{0.31} \\
\midrule
Method & Jul & Aug & Sep & Oct & Nov & Dec \\
\midrule
SPO+     & 0.48 & 0.38 & 0.40 & 0.49 & 0.42 & 0.50 \\
LTR      & 0.33 & \textbf{0.28} & 0.34 & 0.32 & 0.37 & 0.38 \\
MSE      & 0.33 & 0.31 & 0.34 & 0.36 & 0.37 & 0.41 \\
SIG      & \textbf{0.30} & 0.29 & \textbf{0.31} & \textbf{0.29} & \textbf{0.33} & \textbf{0.35} \\
\bottomrule
\end{tabular}
\end{table}

As a representative example, Figure~\ref{fig:real-data-jan} shows the relative
SCT error over training iterations for January 2021.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.5\textwidth]{LossComparison_Jan.png}
    \caption{Relative SCT error during training on the real-world Exam scheduling dataset for January 2021.
    The sigmoid-based regret loss consistently achieves lower SCT error compared to Rank Loss, MSE Loss, and SPO+.}
    \label{fig:real-data-jan}
\end{figure}

Overall, the sigmoid-based surrogate achieves the lowest SCT error. Rank Loss is
competitive early but plateaus higher; MSE underperforms, confirming that
prediction accuracy alone is insufficient; SPO+ converges but stabilizes at
higher error.

\section{Related Work}
\label{sec:related_work}

Task scheduling, a key focus in AI and operations research, involves estimating task durations and using decision-making algorithms to schedule tasks.
This paper explores data-driven approaches for scheduling under task uncertainty. 

\paragraph{Smart predict-and-optimize.}
Traditionally, machine learning is used to predict task durations, which are then used to solve scheduling problems (e.g.,~\cite{shahabikargar2014predicting}).
However, traditional methods often overlook the impact of predictions on decision-making, as they use loss functions like MSE that do not consider the scheduling problem. 
The SPO framework~\cite{elmachtoub2022smart} addresses this by using an SPO loss function that evaluates decision error.
However, the non-convex and discontinuous nature of the SPO loss poses challenges, leading to the development of the surrogate SPO+ loss function.
While effective, SPO assumes deterministic task parameters and struggles with non-linear scenarios.
Several extensions of SPO have been proposed to deal with these limitations and with specific problems.
SPO Trees (SPOTs)~\cite{elmachtoub2020decisiontrees} train decision trees under the SPO framework, providing interpretable models with reduced complexity.
However, they may not generalize well to noisy, non-linear scheduling scenarios.
Applied to large-scale problems like knapsack and energy-cost scheduling~\cite{Mandi2020}, SPO-relax uses relaxation-based oracles to reduce computational costs while maintaining decision quality.
It assumes reliable oracles and focuses on linear objectives.
UNIFY~\cite{Silvestri2024} integrates ML and constrained optimization for multi-stage decision-making under uncertainty.
It supports robust decisions but relies on reinforcement learning and virtual parameters, requiring problem-specific configurations.
Demirovic et al.~\cite{Demirovic2019} explored techniques for minimizing regret in the knapsack problem, highlighting the trade-offs between complexity and performance in combinatorial settings.

\paragraph{Semi- and domain-specific SPO.}
Semi-SPO approaches (e.g.,~\cite{Yang2023Semi,Yan2020Semi}) also use loss functions that are based on the outcome measurements from the optimization step.
These outcome measurements are often chosen to work well in specific domains.
Unlike SPO loss functions, semi-SPO loss functions are not derived from the regret measurement, and consequently cannot be proven to lead to an optimal solution.

Other domain-specific SPO techniques have been proposed, e.g., for transport planning~\cite{tian2023}, factory planning~\cite{Wang2024Refinery}, and energy grid optimization~\cite{Alrasheedi2024Microgrid}.
Like semi-SPO, these use domain-specific loss functions that do not guarantee convergence to the 
true loss of the underlying problem.
Our work also approximates domain-specific loss, yet it provably converges 
to the actual loss function.

\paragraph{Learn to Rank.} 
Our surrogate loss function uses the sigmoid function, common in learn-to-rank (LTR) methods like RankNet~\cite{burges2005learning}, ListWise~\cite{cao2007learning}, and BPR~\cite{rendle2009bpr}.
Compared to these approaches, we introduce a loss function specifically designed to minimize SCT error, making it particularly suitable for scheduling tasks.

\section{Conclusion}
\label{sec:conclusion}

This paper introduced a surrogate-based framework for predict-and-optimize that leverages deterministic, polynomial-time algorithms to construct smooth learning objectives aligned with decision regret.
Within this framework, we developed sigmoid-based surrogates for two canonical scheduling problems under uncertainty: single-machine SCT minimization and two-machine flow shop makespan minimization.
For the SCT problem, we proved that the surrogate converges to the regret loss as the sharpness parameter tends to zero, and empirically demonstrated substantial improvements over predict-then-optimize, SPO+, and LTR baselines on both synthetic and real-world hospital scheduling data.

Our results highlight the value of decision-aware surrogates that redistribute prediction errors in a way that benefits downstream scheduling objectives, rather than focusing solely on pointwise accuracy.
The framework is particularly attractive for problems whose deterministic variants are tractable and structurally interpretable, enabling surrogates that faithfully mirror optimal policies.
Future work will extend our approach to more complex scheduling scenarios (e.g., multi-machine and job shop problems), complete the empirical study of the flow shop surrogate, and explore applications beyond scheduling, such as routing, matching, and resource allocation.

\bibliographystyle{named}
\bibliography{mybibfile}

\end{document}


